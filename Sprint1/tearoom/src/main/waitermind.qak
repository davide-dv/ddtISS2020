/* 
 * ================================================================================
 * waiter.qak
 * VERSION June 1, 2020 
 * 
 * External MQTT sites:
 * 	"mqtt.eclipse.org:  mosquitto.org mqtt.fluux.io  broker.hivemq.com
 * ================================================================================
 */ 

System   tearoom
/*
//mqttBroker "mqtt.eclipse.org" : 1883 eventTopic "unibo/polar" 

// smartbell --> waiter
Request enterrequest : enterrequest(ID)
// waiter --> smartbell
Reply enterreply	 : enterreply(ID, RESULT, MAX_WAIT)
// client --> waiter
Request order : order(ID, TABLE)
// waiter --> client
Reply 	receiveTea : receiveTea(X)
// waiter --> barman
Request transmitOrder : transmitOrder(X)
// barman --> waiter
Reply teaReady : teaReady(X)
// client --> smartbell 
Request ring : ring(X)
// smartbell --> client
Reply canEnter : canEnter(ID)
Reply cannotEnter : cannotEnter(X)
// waiter --> client 
Dispatch atTable : atTable(TABLE)
// client --> waiter
Request paymentRequest : paymentRequest(ID)
// waiter --> client 
Reply readyForPayment : readyForPayment(X) 
// client --> waiter 
Dispatch payment : payment(AMOUNT)
// waiter --> client
Dispatch atExit : atExit(X)
// waiter --> tearoom
Request askFreeTables : askFreeTables(X)
// tearoom --> waiter
Reply replyFreeTables : replyFreeTables(N_TABLES)
// waiter --> all 
Event tableOccupied : tableOccupied(NUM)
// waiter --> all 
Event tableCleaned : tableCleaned(NUM)


Context ctxtearoom   ip [host="localhost" port=8050]
  
QActor waiter context ctxtearoom {  
	[# 
		var FreeTables = 0	
		
		
			
	#]
	
	State start initial {
		println("Waiter Mind: Started")
	} Goto listening
	
	State listening {
		println("Waiter Mind: Listening")			
	} Transition t0 whenTime 5000 -> goHome 
					whenRequest enterrequest -> tableCheck
					whenRequest order -> transmitToBarman
					whenReply teaReady -> getTea
					whenRequest paymentRequest -> reachTableForPayement	
	
	State tableCheck {   // request/reply alla tearoom 
		println("Waiter Mind: Checking tables")
		request tearoom -m askFreeTables : askFreeTables(tables)
	} Transition t3 whenReply replyFreeTables -> evaluateFreeTables
	
	State evaluateFreeTables {
		println("Waiter Mind: Evaluating the number of free tables")
		onMsg(replyFreeTables : replyFreeTables(N_TABLES)) {			
			[# FreeTables = payloadArg(0).toInt() #]
			println("Free tables: $FreeTables")		
		}		
	} Goto accept if[# FreeTables > 0 #] else refuse
	
	State refuse {
		println("REFUSE")
	}
	
	State accept {		 
		println("Waiter Mind: Accepting client")			
		replyTo enterrequest with enterreply : enterreply(1, enter, 0)
	} Goto reachEntrance
	
	State reachEntrance {	// dovrà avere un atEntrance dal walker 
		println("Waiter Mind: Reaching Entrance")
		delay 1000
	} Goto convoyClient
	
	State convoyClient {  // dovrà avere un atTable dal walker 
		println("Waiter Mind: Reaching Table")
		delay 1000		
		updateResource [# "atTable" #]
		forward client -m atTable : atTable(1)
		emit tableOccupied : tableOccupied(1) 
		delay 500
	} Goto listening /*Goto tableCheck*/
	
/*	State transmitToBarman {
		println("Waiter Mind: Transmitting order to barman")
		request barman -m transmitOrder : transmitOrder(tea)		
	} Goto listening
	
	State getTea {	// deve arrivare un messaggio dal walker 
		println("Waiter Mind: Going to get the tea")
		delay 1000		
	} Goto serveClient
	
	State serveClient { // deve arrivare un messaggio dal walker
		println("Waiter Mind: Going to serve the client")
		delay 2000	
		replyTo order with receiveTea : receiveTea(tea)
	} Goto listening 
	
	State reachTableForPayement { // deve arrivare un messaggio dal walker
		println("Waiter Mind: Going to the table for collecting payment")
		delay 1000		
		replyTo paymentRequest with readyForPayment : readyForPayment(ready)
	} Goto collectPayment	
	
	State collectPayment {
		println("Waiter Mind: Collecting the payment")	
	} Transition t2 whenMsg payment -> convoyAtExit  
	
	State convoyAtExit {
		println("Waiter Mind: Taking the client to the exit")
		delay 1000
		forward client -m atExit : atExit(exit)		
	} Goto reachTableForCleaning
	
	State reachTableForCleaning { // messaggio dal walker
		println("Waiter Mind: Going to clean the table")
		delay 1000		
	} Goto cleanTable
	
	State cleanTable {
		println("Waiter Mind: Cleaning the table")
		delay 1000		
		emit tableCleaned : tableCleaned(1)  
	} Goto listening
	
	State goHome { // messaggio dal walker 
		println("Waiter Mind: Going home")
		delay 1000	
	} Goto listening 
    
 }
 
 QActor smartbell context ctxtearoom {
 	
 	State handleRequest initial {
 		println("Smart Bell: Start and listening")
 		updateResource [# "handleRequest" #] 		
 		//delay 1000
 		
 	} Transition t0 whenRequest ring -> checkTemperature	
 	
 	State checkTemperature {
 		println("Smart Bell: Checking client temperature")
 		//replyTo ring with canEnter : canEnter(1)
 		//replyTo ring with cannotEnter : cannotEnter(38)
 		updateResource [# "Temperature_OK" #] 	
 		delay 2000	
 		request waiter -m enterrequest : enterrequest(1) 		
 	} Transition t1 whenReply enterreply -> inform
 	
 	State inform {
 		println("Smart Bell: ")
 		onMsg(enterreply : enterreply(ID, RESULT, MAX_TIME)) {			
			[# 	 
				val id = payloadArg(0)	
				val result = payloadArg(1)
				val maxTime = payloadArg(2)			
			#]
			updateResource [# result + " " + maxTime #] 					
		} 		
		delay 1000
 	} Goto handleRequest
 }
 
QActor client context ctxtearoom {
 	
    State s0 initial {
 		println("Client FERMO") 			
 	}
    
    /*
    State s0 initial {
 		println("Client: Start")
 		delay 5000		
 		request smartbell -m ring : ring(a)	
 	} Transition t0 whenReply canEnter -> waitingAtEntrance
 					whenReply cannotEnter -> goHome					
 					
 	State waitingAtEntrance {
 		println("Client: Waiting at the entrance")		
 	} Transition t1 whenMsg enterreply -> reachingTable
 	
 	State reachingTable {
 		println("Client: Reaching the Table") 		
 	} Transition t2 whenMsg atTable -> ordering
 	
 	State ordering {
 		println("Client: Ordering a tea")
 		delay 500
 		request waiter -m order : order(1, 1) 		
 	} Goto waitForTea
 	
 	State waitForTea {
 		println("Client: Waiting for tea")		
 	} Transition t3 whenReply receiveTea -> consuming
 	
 	State consuming {
 		println("Client: Consuming the tea")
 		delay 1000 		
 	} Goto requirePayment
 	
 	State requirePayment {
 		println("Client: Requiring payment")		
 		request waiter -m paymentRequest : paymentRequest(1)
 	} Transition t4 whenReply readyForPayment -> paying
 	
 	State paying {
 		println("Client: Paying")
 		forward waiter -m payment : payment(2)		
 	} Goto reachingExit
 	
 	State reachingExit {
 		println("Client: Reaching the Exit") 		
 	} Transition t5 whenMsg atExit -> goHome
 	
 	State goHome {
 		println("Client: Going Home")
 		terminate 0		
 	} 	
 } 
 
 QActor barman context ctxtearoom {	
	
	State waitingOrder initial {
		println("Barman waiting for an order")		
	} Transition t0 whenRequest transmitOrder -> prepareTea 
	
	State prepareTea {
		println("Barman preparing tea")
		delay 2000
		replyTo transmitOrder with teaReady : teaReady(tea)  		
	} Goto waitingOrder	
} 

QActor tearoom context ctxtearoom {
	
	[#
		var FreeTables = 2
		
	#]
	
	State listening initial {
		println("Tearoom: Started and listening")
		updateResource [# FreeTables.toString() #]
		
	} Transition t0 whenRequest askFreeTables -> transmitFreeTables
					whenEvent tableOccupied -> updateFreeTables
					whenEvent tableCleaned -> updateFreeTables
	
	State transmitFreeTables {
		println("Tearoom: Communicating the number of free tables")
		replyTo askFreeTables with replyFreeTables : replyFreeTables($FreeTables)		
	} Goto listening
	
	State updateFreeTables {
		println("Tearoom: Updating the number of free tables")		
		
		onMsg(tableOccupied : tableOccupied(NUM)) {			
			[# FreeTables -- #]
			println("Free tables: $FreeTables")			
		}
		
		onMsg(tableCleaned : tableCleaned(NUM)) {			
			[# FreeTables ++ #]
			println("Free tables: $FreeTables")				 				
		}	
	} Goto listening
}*/