/* Generated by AN DISI Unibo */ 
package it.unibo.walker

import it.unibo.kactor.*
import alice.tuprolog.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
	
class Walker ( name: String, scope: CoroutineScope  ) : ActorBasicFsm( name, scope ){

	override fun getInitialState() : String{
		return "handleCommand"
	}
	@kotlinx.coroutines.ObsoleteCoroutinesApi
	@kotlinx.coroutines.ExperimentalCoroutinesApi			
	override fun getBody() : (ActorBasicFsm.() -> Unit){
		
				var DestX = 0
				var DestY = 0 	
				
				var CurrentMove = ""		
				//val StepTime = 380L
				val StepTime = 360L	
				var obstacleFound = false
				val BackTime = 2 * StepTime / 3
			
		return { //this:ActionBasciFsm
				state("handleCommand") { //this:State
					action { //it:State
						println("Walker: started and waiting for commands")
					}
					 transition(edgeName="t018",targetState="walk",cond=whenRequest("movetoCell"))
				}	 
				state("walk") { //this:State
					action { //it:State
						if( checkMsgContent( Term.createTerm("movetoCell(X,Y)"), Term.createTerm("movetoCell(X,Y)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								
												DestX = payloadArg(0).toInt()
												DestY = payloadArg(1).toInt()
								itunibo.planner.plannerUtil.planForGoal( "$DestX", "$DestY"  )
						}
					}
					 transition( edgeName="goto",targetState="executePlan", cond=doswitchGuarded({ itunibo.planner.plannerUtil.existActions()  
					}) )
					transition( edgeName="goto",targetState="noPlan", cond=doswitchGuarded({! ( itunibo.planner.plannerUtil.existActions()  
					) }) )
				}	 
				state("noPlan") { //this:State
					action { //it:State
						println("Walker: plan not found")
					}
					 transition( edgeName="goto",targetState="handleCommand", cond=doswitch() )
				}	 
				state("executePlan") { //this:State
					action { //it:State
						  CurrentMove = itunibo.planner.plannerUtil.getNextPlannedMove()  
						delay(250) 
					}
					 transition( edgeName="goto",targetState="moveForward", cond=doswitchGuarded({ CurrentMove == "w"  
					}) )
					transition( edgeName="goto",targetState="rotate", cond=doswitchGuarded({! ( CurrentMove == "w"  
					) }) )
				}	 
				state("moveForward") { //this:State
					action { //it:State
						request("step", "step($StepTime)" ,"basicrobot" )  
					}
					 transition(edgeName="t019",targetState="stepDone",cond=whenReply("stepdone"))
					transition(edgeName="t020",targetState="stepFailed",cond=whenReply("stepfail"))
				}	 
				state("stepDone") { //this:State
					action { //it:State
						itunibo.planner.plannerUtil.updateMap( "w"  )
					}
					 transition( edgeName="goto",targetState="executePlan", cond=doswitchGuarded({ CurrentMove.length > 0  
					}) )
					transition( edgeName="goto",targetState="notifySuccess", cond=doswitchGuarded({! ( CurrentMove.length > 0  
					) }) )
				}	 
				state("notifySuccess") { //this:State
					action { //it:State
						println("Walker: $DestX,$DestY reached")
						itunibo.planner.plannerUtil.showCurrentRobotState(  )
						answer("movetoCell", "atcell", "atcell($DestX,$DestY)"   )  
					}
					 transition( edgeName="goto",targetState="handleCommand", cond=doswitch() )
				}	 
				state("stepFailed") { //this:State
					action { //it:State
						println("Walker: step failed")
						 obstacleFound = true  
						if( checkMsgContent( Term.createTerm("stepfail(V)"), Term.createTerm("stepfail(DURATION,CAUSE)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								 val Duration = payloadArg(0).toLong()  ; val Dt = Math.abs(StepTime-Duration); val BackT = Duration/2  
								println("Walker stepFail Duration = $Duration, BackTime = ${BackTime}")
								if(  Duration > BackTime  
								 ){forward("cmd", "cmd(s)" ,"basicrobot" ) 
								delay(BackT)
								forward("cmd", "cmd(h)" ,"basicrobot" ) 
								}
						}
						itunibo.planner.plannerUtil.updateMapObstacleOnCurrentDirection(  )
					}
					 transition( edgeName="goto",targetState="handleCommand", cond=doswitch() )
				}	 
				state("rotate") { //this:State
					action { //it:State
						if(  CurrentMove == "l" || CurrentMove == "r"   
						 ){forward("cmd", "cmd($CurrentMove)" ,"basicrobot" ) 
						itunibo.planner.plannerUtil.updateMap( "$CurrentMove"  )
						}
					}
					 transition( edgeName="goto",targetState="executePlan", cond=doswitchGuarded({ CurrentMove.length > 0  
					}) )
					transition( edgeName="goto",targetState="notifySuccess", cond=doswitchGuarded({! ( CurrentMove.length > 0  
					) }) )
				}	 
			}
		}
}
